#+setupFile: ../org/latex_setup.org
#+title: FrostServer
#+author: Lewis Collum

* Installing Nginx, Flask, and GUnicorn
  Since we are using Arch Linux ARM on our Pi, we used Arch Linux's
  package manager ~pacman~ for Nginx and Gunicorn. We used ~pip~ to
  install Flask.

  #+begin_src bash
sudo pacman -S nginx
sudo pacman -S gunicorn
sudo pip install flask
  #+end_src

* Starting the Server the First time
  For ease, this repository was cloned on our Raspberry Pi to the user
  directory (e.g. "/home/alarm"). In the =frostServer/config= directory,
  there is a setup script[fn:asSudo] which does the following:
  
  1. links the frostServer.service to the system directory;
  2. links the frostServer.nginx config file to nginx's enabled-sites
     directory;
  3. enables both the nginx and the frostServer services;
  4. starts both services.
  
  Now, on a computer connected to the same WiFi as our Pi, we can type
  the IP of the Pi into the browser search bar (e.g. "192.168.0.106")
  and the Frost website appears. Since we enabled the server service,
  the server will start at boot without any user intervention.

* Server Overview: Flask, GUnicorn, and Nginx
  We use Flask, GUnicorn, and Nginx. Let's work our way down, from the
  website, to our application code (in python).

  *Nginx* acts as our web server, fulfilling requests from clients for
  static content from our website (e.g. HTML pages, files and
  images). Nginx forwards dynamic requests (e.g. all of the requests 
  that we want Python to handle) to GUnicorn, our 
  application server.

  *GUnicorn* ensures that Nginx and our Flask Python application can
  talk to each other. Ultimately, GUnicorn routes requests (passed
  through Nginx) to their corresponding function in our Flask
  application.

  *Flask* is a web [[https://en.wikipedia.org/wiki/Microframework][microframework]] in the form of a Python library. It is
  used in our Python application to provide functions that can receive
  requests, and return a response (e.g. sensor data).

  [[./figure/blocks/block_server.png]]

** Example: Real-Time Sensor Reading
  We have real-time plots on our front-end that request sensor
  data. Eventually, we expect to receive this sensor data from a URL
  of our choice (e.g. "/sensor_reading"). These requests are sent to
  Nginx, which are then passed to GUnicorn (since they are dynamic
  requests). GUnicorn sends the requests to a function in our python
  application that is registered for the formerly mentioned URL. The
  function is registered with the given URL using Flask. This function
  has code to get sensor data from the underlying linux system
  (typically, by reading a sensor file or running a shell
  command). Finally, the function returns a response which contains
  the sensor data.
  
** Resources :noexport:
   - https://en.wikipedia.org/wiki/Multitier_architecture
   - https://serverfault.com/questions/331256/why-do-i-need-nginx-and-something-like-gunicorn
   - https://www.nginx.com/resources/glossary/application-server-vs-web-server/
   - https://flask.palletsprojects.com/en/1.1.x/api/#flask.Flask.route

  
# * Server Started at Boot
# Stuff about systemctl

# * Developing with Flask
# export FLASK_ENV=development
* Footnotes :ignore:
[fn:asSudo] The setup script should be run as =sudo=.
