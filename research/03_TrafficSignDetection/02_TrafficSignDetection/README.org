#+setupfile: ../../research.org

#+title: Traffic Sign Detection
#+date: Updated: \today
#+author: Lewis Collum
*Started 02/18/2020*

* Downloading the German Traffic Sign Detection Benchmark, GTSDB
  The following downloads the dataset, unzips it, and moves the
  internal directories around (and changes their name) to match my
  prefered directory convention.
 #+begin_src bash :async :results silent
setName="FullIJCNN2013"
set=$setName.zip
dataDirectory="data"

function main() {
    #downloadSet
    #unzipSet
    configureSet
    echo "DONE!"
}

function downloadSet() {
    if [[ ! -f $set ]]; then
        wget https://sid.erda.dk/public/archives/ff17dc924eba88d5d01a807357d6614c/$set
    fi;
}

function unzipSet() {
    if [[ -f $set && ! -d $dataDirectory ]]; then 
        unzip $set
        mv $setName $dataDirectory
    fi
}

function configureSet() {
    sed 's/;/,/g' $dataDirectory/gt.txt > $dataDirectory/gt.csv
}

main $@
 #+end_src
* Path Organization
  #+begin_src python :tangle source/path/__init__.py :exports none
from path import data
  #+end_src

  #+begin_src python :tangle source/path/data.py
gt = "../data/gt.csv"
names = "../data/names.csv"
train = "../data/"
  #+end_src
* Batch: Preperation with ImageDataGenerator and DirectoryIterator
  =batch.py=
  #+begin_src python :tangle source/batch.py :results silent
from keras.preprocessing.image import ImageDataGenerator
import numpy
import matplotlib.pyplot as pyplot
from textwrap import wrap
import pandas

import path

names = pandas.read_csv(path.data.names)
titles = names['title'].values

imageSize = (800, 1360)
size = 32

batchGenerator = ImageDataGenerator(
    rescale = 1.0/255,
    validation_split = 0.2)

trainIterator = batchGenerator.flow_from_directory(
    directory = path.data.train,
    batch_size = size,
    shuffle = True,
    target_size = imageSize,
    subset = 'training')

validationIterator = batchGenerator.flow_from_directory(
    directory = path.data.train,
    batch_size = size,
    shuffle = True,
    target_size = imageSize,
    subset = 'validation')

_images, _labels = trainIterator.next()
classCount = len(_labels[0])
sampleClasses = trainIterator.labels
sampleSize = trainIterator.n
imageShape = _images[0].shape

def classFromLabelsAt(labels, index):
    return numpy.where(labels[index] == 1)[0][0]

def nameFromLabelsAt(labels, index):
    return titles[classFromLabelsAt(labels, index)]

def plot(images, labels, columns=5, rows=5):
    figure, axes = pyplot.subplots(rows, columns, figsize=(8,2*rows))
    figure.subplots_adjust(hspace = .6)

    for n in range(min(columns*rows, len(images))):
        if len(images[n, 0, 0]) == 1:
            figure.axes[n].imshow(images[n].reshape((imageSize, imageSize)), cmap='gray')
        else:
            figure.axes[n].imshow(images[n])

        title = nameFromLabelsAt(labels, n).title()
        wrappedTitle = "\n".join(wrap(title, 18))
        figure.axes[n].set_title(wrappedTitle, fontsize=10)

    for subplotAxes in figure.axes: subplotAxes.axis('off')
    figure.tight_layout()

def quickPlot():
    plot(_images, _labels, columns=5, rows=2)
  #+end_src 

** Plot
   #+begin_src python :results silent :async
import matplotlib.pyplot as pyplot

import batch

batch.quickPlot()
pyplot.show()
   #+end_src
* Resources
  #+begin_export latex
  \scriptsize
  #+end_export

  - https://www.learnopencv.com/training-yolov3-deep-learning-based-custom-object-detector/
